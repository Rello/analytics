/*!
 * chartjs-plugin-annotation v3.1.0
 * https://www.chartjs.org/chartjs-plugin-annotation/latest/
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
(function(global, factory) {
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = factory(global.Chart || require('chart.js'));
  } else if (typeof define === 'function' && define.amd) {
    define(['chart.js'], factory);
  } else {
    global.ChartAnnotation = factory(global.Chart);
  }
})(typeof window !== 'undefined' ? window : this, function(Chart) {

const annotationPlugin = {
  id: 'annotation',
  
  beforeDatasetsDraw(chart, args, options) {
    const { ctx, chartArea, scales } = chart;
    const annotations = options.annotations || {};
    
    if (!chartArea) return;
    
    ctx.save();
    
    Object.keys(annotations).forEach(id => {
      const annotation = annotations[id];
      if (!annotation || annotation.display === false) return;
      
      if (annotation.type === 'line') {
        this.drawLine(ctx, chartArea, scales, annotation);
      }
    });
    
    ctx.restore();
  },
  
  drawLine(ctx, chartArea, scales, annotation) {
    const { left, right, top, bottom } = chartArea;
    let x1, y1, x2, y2;
    
    if (annotation.scaleID) {
      const scale = scales[annotation.scaleID];
      if (!scale) return;
      
      const pixel = scale.getPixelForValue(annotation.value);
      
      if (scale.isHorizontal()) {
        // Vertical line
        x1 = x2 = pixel;
        y1 = top;
        y2 = bottom;
      } else {
        // Horizontal line
        x1 = left;
        x2 = right;
        y1 = y2 = pixel;
      }
    } else {
      // Default to horizontal line on primary y-axis
      const yScale = scales.y || scales.primary;
      if (!yScale) return;
      
      const pixel = yScale.getPixelForValue(annotation.value);
      x1 = left;
      x2 = right;
      y1 = y2 = pixel;
    }
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    
    ctx.strokeStyle = annotation.borderColor || '#ff0000';
    ctx.lineWidth = annotation.borderWidth || 2;
    ctx.lineDashOffset = annotation.borderDashOffset || 0;
    
    if (annotation.borderDash) {
      ctx.setLineDash(annotation.borderDash);
    }
    
    ctx.stroke();
    
    // Draw label if provided
    if (annotation.label && annotation.label.content) {
      this.drawLabel(ctx, x1, y1, x2, y2, annotation.label);
    }
  },
  
  drawLabel(ctx, x1, y1, x2, y2, label) {
    const content = label.content;
    const fontSize = label.font?.size || 12;
    const fontFamily = label.font?.family || 'Arial';
    const color = label.color || '#333';
    const backgroundColor = label.backgroundColor || 'rgba(255, 255, 255, 0.8)';
    const padding = label.padding || 4;
    
    ctx.font = `${fontSize}px ${fontFamily}`;
    const textWidth = ctx.measureText(content).width;
    const textHeight = fontSize;
    
    // Position label
    let labelX, labelY;
    if (x1 === x2) {
      // Vertical line
      labelX = x1 + 5;
      labelY = y1 + 20;
    } else {
      // Horizontal line
      labelX = x1 + 5;
      labelY = y1 - 5;
    }
    
    // Draw background
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(labelX - padding, labelY - textHeight - padding, textWidth + 2 * padding, textHeight + 2 * padding);
    
    // Draw text
    ctx.fillStyle = color;
    ctx.fillText(content, labelX, labelY);
  }
};

// Register the plugin if Chart is available
if (typeof Chart !== 'undefined' && Chart.register) {
  Chart.register(annotationPlugin);
}

return annotationPlugin;

});